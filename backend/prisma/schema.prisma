// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enum for organization type
enum OrganizationType {
  client
  expert
}

model Organization {
  id              String          @id @default(uuid())
  name            String
  description     String?         // Organization description
  website         String?         // Organization website URL
  type            OrganizationType
  subscriptionTier String         @map("subscription_tier")
  logoUrl         String?         @map("logo_url")
  customTerminology Json?         @map("custom_terminology") // Stored as JSON
  settings        Json?           // Organization-specific settings
  createdAt       DateTime        @default(now()) @map("created_at")
  updatedAt       DateTime        @updatedAt @map("updated_at")
  users           User[]
  roles           Role[]
  integrations    Integration[]
  workers         Worker[]        // Relation to Worker
  segments        Segment[]       // Relation to Segment

  @@map("organizations")
}

model User {
  id            String   @id @default(uuid())
  email         String   @unique
  name          String?
  password      String
  status        String?  @default("active")
  lastLoginAt   DateTime? @map("last_login_at")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")
  
  // Relation to Organization
  organizationId String?       @map("organization_id")
  organization   Organization? @relation(fields: [organizationId], references: [id])
  
  // Relation to Role
  roleId        String?       @map("role_id")
  role          Role?         @relation(fields: [roleId], references: [id])
  
  // Relation to UserPreferences
  preferences    UserPreferences?
  
  // Relation to segments (for created/modified by)
  createdSegments Segment[] @relation("CreatedBy")
  updatedSegments Segment[] @relation("UpdatedBy")

  @@map("users")
}

model UserPreferences {
  id                  String   @id @default(uuid())
  userId              String   @unique @map("user_id")
  user                User     @relation(fields: [userId], references: [id])
  theme               String   @default("system")
  language            String   @default("en")
  emailNotifications  Boolean  @default(true) @map("email_notifications")
  pushNotifications   Boolean  @default(true) @map("push_notifications")
  timezone            String   @default("UTC")
  dateFormat          String   @default("YYYY-MM-DD") @map("date_format")
  customSettings      Json?    @map("custom_settings")
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")

  @@map("user_preferences")
}

model Role {
  id              String       @id @default(uuid())
  name            String
  displayName     String       @map("display_name")
  description     String?      @default("")
  isDefault       Boolean      @default(false) @map("is_default")
  permissions     Json         // Stored as JSON array of permission strings
  createdAt       DateTime     @default(now()) @map("created_at")
  updatedAt       DateTime     @updatedAt @map("updated_at")
  
  // Relation to Organization
  organizationId  String       @map("organization_id")
  organization    Organization @relation(fields: [organizationId], references: [id])

  // Relation to Users
  users          User[]

  @@map("roles")
}

model Integration {
  id            String       @id @default(uuid())
  type          String
  config        Json
  status        String      @default("inactive")
  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")
  
  // Relation to Organization
  organizationId String      @map("organization_id")
  organization   Organization @relation(fields: [organizationId], references: [id])

  @@map("integrations")
}

// Worker-related enums
enum Gender {
  male
  female
  non_binary
  other
  prefer_not_say
}

enum OptInStatus {
  opted_in
  opted_out
  pending
  failed
}

enum EmploymentStatus {
  active
  inactive
  on_leave
  terminated
}

enum EmploymentType {
  full_time
  part_time
  contractor
  temporary
}

enum DeactivationReason {
  voluntary_resignation
  performance_issues
  policy_violation
  redundancy
  retirement
  end_of_contract
  other
}

// Core Worker model - contains only essential worker information
model Worker {
  id                     String           @id @default(uuid())
  externalId             String?          @map("external_id")
  firstName              String           @map("first_name")
  lastName               String           @map("last_name")
  dateOfBirth            DateTime?        @map("date_of_birth")
  gender                 Gender?
  tags                   String[]
  customFields           Json?            @map("custom_fields")  // Moving customFields back to the core Worker model
  
  // Timestamps
  createdAt              DateTime         @default(now()) @map("created_at")
  updatedAt              DateTime         @updatedAt @map("updated_at")

  // Relationships
  organizationId         String           @map("organization_id")
  organization           Organization     @relation(fields: [organizationId], references: [id])

  // Relations to other worker-related tables
  contact               WorkerContact?
  employment            WorkerEmployment?
  engagement            WorkerEngagement?
  wellbeing             WorkerWellbeing?
  gamification          WorkerGamification?
  
  // Self-relation for supervisor (kept in core table for simplicity)
  supervisorId           String?          @map("supervisor_id")
  supervisor             Worker?          @relation("WorkerToSupervisor", fields: [supervisorId], references: [id])
  supervisees            Worker[]         @relation("WorkerToSupervisor")

  // Relation to segments
  segmentMemberships     SegmentMembership[]

  isActive            Boolean              @default(true)
  deactivationReason  DeactivationReason?

  @@map("workers")
  @@index([organizationId])
}

// Worker contact information
model WorkerContact {
  id                     String           @id @default(uuid())
  workerId               String           @unique @map("worker_id")
  worker                 Worker           @relation(fields: [workerId], references: [id], onDelete: Cascade)
  
  // Location
  locationCity           String?          @map("location_city")
  locationStateProvince  String?          @map("location_state_province")
  locationCountry        String?          @map("location_country")
  
  // Contact & Communication
  primaryPhoneNumber     String           @unique @map("primary_phone_number")
  whatsappOptInStatus    OptInStatus      @map("whatsapp_opt_in_status")
  preferredLanguage      String           @map("preferred_language")
  communicationConsent   Boolean          @default(false) @map("communication_consent")
  emailAddress           String?          @map("email_address")
  
  // Timestamps
  createdAt              DateTime         @default(now()) @map("created_at")
  updatedAt              DateTime         @updatedAt @map("updated_at")

  @@map("worker_contacts")
  @@index([primaryPhoneNumber])
}

// Worker employment information
model WorkerEmployment {
  id                     String           @id @default(uuid())
  workerId               String           @unique @map("worker_id")
  worker                 Worker           @relation(fields: [workerId], references: [id], onDelete: Cascade)
  
  // Employment & Organizational Data
  jobTitle               String?          @map("job_title")
  department             String?
  team                   String?
  hireDate               DateTime?        @map("hire_date")
  employmentStatus       EmploymentStatus @default(active) @map("employment_status")
  employmentType         EmploymentType?  @map("employment_type")
  
  // Timestamps
  createdAt              DateTime         @default(now()) @map("created_at")
  updatedAt              DateTime         @updatedAt @map("updated_at")

  @@map("worker_employments")
  @@index([employmentStatus])
  @@index([department])
  @@index([team])
}

// Worker platform engagement data
model WorkerEngagement {
  id                     String           @id @default(uuid())
  workerId               String           @unique @map("worker_id")
  worker                 Worker           @relation(fields: [workerId], references: [id], onDelete: Cascade)
  
  // Platform Engagement
  lastActiveAt           DateTime?        @map("last_active_at")
  lastInteractionDate    DateTime?        @map("last_interaction_date")
  
  // Timestamps
  createdAt              DateTime         @default(now()) @map("created_at")
  updatedAt              DateTime         @updatedAt @map("updated_at")

  @@map("worker_engagements")
  @@index([lastActiveAt])
  @@index([lastInteractionDate])
}

// Worker wellbeing assessment data
model WorkerWellbeing {
  id                         String     @id @default(uuid())
  workerId                   String     @unique @map("worker_id")
  worker                     Worker     @relation(fields: [workerId], references: [id], onDelete: Cascade)
  
  // Wellbeing Data
  lastWellbeingAssessmentDate DateTime?  @map("last_wellbeing_assessment_date")
  overallWellbeingScore       Float?     @map("overall_wellbeing_score")
  
  // Timestamps
  createdAt                  DateTime   @default(now()) @map("created_at")
  updatedAt                  DateTime   @updatedAt @map("updated_at")

  @@map("worker_wellbeings")
  @@index([lastWellbeingAssessmentDate])
  @@index([overallWellbeingScore])
}

// Worker gamification data
model WorkerGamification {
  id                     String           @id @default(uuid())
  workerId               String           @unique @map("worker_id")
  worker                 Worker           @relation(fields: [workerId], references: [id], onDelete: Cascade)
  
  // Gamification Data
  pointsBalance          Int              @default(0) @map("points_balance")
  badgesEarnedCount      Int              @default(0) @map("badges_earned_count")
  
  // Timestamps
  createdAt              DateTime         @default(now()) @map("created_at")
  updatedAt              DateTime         @updatedAt @map("updated_at")

  @@map("worker_gamifications")
  @@index([pointsBalance])
}

// Segment-related enums
enum SegmentType {
  static     // Manually defined with explicit membership
  rule_based // Dynamically calculated based on rules
}

enum SegmentSyncStatus {
  pending
  processing
  completed
  failed
}

// Segment model
model Segment {
  id                String        @id @default(uuid())
  name              String
  description       String?
  type              SegmentType
  ruleDefinition    Json?         @map("rule_definition") // JSON object containing rule definition for rule-based segments
  workerCount       Int           @default(0) @map("worker_count")
  lastSyncAt        DateTime?     @map("last_sync_at") // When segment membership was last recalculated (for rule-based segments)
  createdAt         DateTime      @default(now()) @map("created_at")
  updatedAt         DateTime      @updatedAt @map("updated_at")
  
  // Organization relation
  organizationId    String        @map("organization_id")
  organization      Organization  @relation(fields: [organizationId], references: [id])
  
  // User audit relations
  createdById       String?       @map("created_by_id")
  createdBy         User?         @relation("CreatedBy", fields: [createdById], references: [id])
  updatedById       String?       @map("updated_by_id")
  updatedBy         User?         @relation("UpdatedBy", fields: [updatedById], references: [id])
  
  // Worker membership relation
  members           SegmentMembership[]
  
  // Sync job relation
  syncJobs          SegmentSyncJob[]

  @@map("segments")
  @@index([organizationId])
  @@index([type])
  @@index([lastSyncAt])
}

// Worker-Segment membership model
model SegmentMembership {
  id                String        @id @default(uuid())
  workerId          String        @map("worker_id")
  worker            Worker        @relation(fields: [workerId], references: [id], onDelete: Cascade)
  segmentId         String        @map("segment_id")
  segment           Segment       @relation(fields: [segmentId], references: [id], onDelete: Cascade)
  ruleMatch         Boolean       @default(false) @map("rule_match") // Whether membership is due to rule match (true) or manual assignment (false)
  ruleMatchReason   String?       @map("rule_match_reason") // Description of which rules matched, stored as text
  addedAt           DateTime      @default(now()) @map("added_at")
  
  @@unique([workerId, segmentId]) // A worker can only appear once in a segment
  @@map("segment_memberships")
  @@index([workerId])
  @@index([segmentId])
  @@index([ruleMatch])
}

// Segment synchronization job model
model SegmentSyncJob {
  id                String             @id @default(uuid())
  segmentId         String             @map("segment_id")
  segment           Segment            @relation(fields: [segmentId], references: [id], onDelete: Cascade)
  status            SegmentSyncStatus  @default(pending)
  startedAt         DateTime?          @map("started_at")
  completedAt       DateTime?          @map("completed_at")
  processedCount    Int                @default(0) @map("processed_count") // Number of workers processed
  matchCount        Int                @default(0) @map("match_count") // Number of workers matching the rules
  errorMessage      String?            @map("error_message")
  createdAt         DateTime           @default(now()) @map("created_at")
  updatedAt         DateTime           @updatedAt @map("updated_at")
  
  @@map("segment_sync_jobs")
  @@index([segmentId])
  @@index([status])
}
